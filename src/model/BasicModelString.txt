%% Model to find unreachable options don't need all solutions

% INPUT: The "values" to be chosen for all the options.
enum Property;

% Model Decisions: Which properties can be chosen together.
array[Property] of var bool: reachable ::no_output;

set of Property: reachable_prop ::output ::output_only = {p | p in Property where fix(reachable[p])};

% Set the properties that have already been chosen by the user
%           (INPUT), enforcing them to be chosen by the model.
set of Property: been_chosen;
constraint forall(p in been_chosen) (reachable[p]);

% Constraint: IF a property has one or more possible dependency chains (INPUT),
%             ensure that when all the chains of this property are not avaible,
%             this property will not be reachable too.
list of record(Property: p, list of Property: req): dependencies; 
constraint forall(p in Property where length([0 | i in index_set(dependencies) where dependencies[i].p = p]) > 0) (
    forall(i in index_set(dependencies) where p = dependencies[i].p) (
      exists(r in dependencies[i].req) (reachable[r] = false)
    )  -> reachable[p] = false
);


% Constraint: For the cards contains proeperties that have been chosen by the user,
%             the number of options that could be chosed will be in card.n
list of record(set of Property: props, set of int: n): card;
constraint forall(i in index_set(card)) (
  exists(p in card[i].props)(p in been_chosen) -> 
  count(p in card[i].props)(reachable[p]) in card[i].n
);

% To get the options impossible to reach
solve minimize count(p in Property)(reachable[p] = false);
